using Microsoft.CodeAnalysis;
using SREmulator.SourceGeneration.Constants;
using System.Collections.Generic;
using System.Text;

namespace SREmulator.SourceGeneration
{
    [Generator(LanguageNames.CSharp)]
    public sealed class SRCharacterGenerator : SRItemGenerator
    {
        public override string Keys => SRKeys.SRCharacterKeys;
        public override string Type => SRItemTypes.Character;
        public override string Attribute => SRAttributes.SRCharacterAttribute;

        public override string GetClassType(int rarity)
        {
            if (rarity is 5)
                return "SRStar5Character";

            return "SRStar4Character";
        }
    }

    [Generator(LanguageNames.CSharp)]
    public sealed class SRLightConeGenerator : SRItemGenerator
    {
        public override string Keys => SRKeys.SRLightConeKeys;
        public override string Type => SRItemTypes.LightCone;
        public override string Attribute => SRAttributes.SRLightConeAttribute;

        public override string GetClassType(int rarity)
        {
            if (rarity is 5)
                return "SRStar5LightCone";

            if (rarity is 4)
                return "SRStar4LightCone";

            return "SRStar3LightCone";
        }
    }

    public abstract class SRItemGenerator : ISourceGenerator
    {
        public abstract string Keys { get; }
        public abstract string Type { get; }
        public abstract string Attribute { get; }

        private struct ItemData
        {
            public string Key;
            public int Rarity;
            public string Type;
            public string[] Names;
        }

        public abstract string GetClassType(int rarity);

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(SRKeysClassReceiver.Creator(Keys));
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var receiver = (SRKeysClassReceiver)context.SyntaxContextReceiver;
            var semanticModel = context.Compilation.GetSemanticModel(receiver.Keys.SyntaxTree);
            var keys = Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(semanticModel, receiver.Keys);
            List<ItemData> items = new List<ItemData>();

            foreach (var member in keys.GetMembers())
            {
                ItemData item = default;

                var attributeData = member.GetAttribute(SRAttributes.SRAliasesAttribute);
                attributeData.Deconstruct(0, out item.Names);

                attributeData = member.GetAttribute(Attribute);
                attributeData.Deconstruct(0, out item.Key);
                attributeData.Deconstruct(1, out item.Rarity);
                item.Type = GetClassType(item.Rarity);

                items.Add(item);
            }

            StringBuilder builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("namespace SREmulator.SRItems;");
            builder.AppendLine();
            builder.AppendLine($"partial class SR{Type}s");
            builder.AppendLine("{");
            foreach (var item in items)
            {
                builder.AppendLine(1, $"private static {item.Type}? _{item.Key} = null;");
                builder.AppendLine(1, $"public static {item.Type} {item.Key} => _{item.Key} ??= new {item.Key}();");
            }
            builder.AppendLine(1, $"public static partial SR{Type}? GetItemByName(string? name)");
            builder.AppendLine(1, "{");
            builder.AppendLine(2, "return name?.ToLower() switch");
            builder.AppendLine(2, "{");
            foreach (var item in items)
            {
                builder.AppendLine(3, $"\"{string.Join("\" or \"", item.Names)}\" => {item.Key},");
            }
            builder.AppendLine(3, $"_ => null");
            builder.AppendLine(2, "};");
            builder.AppendLine(1, "}");
            builder.AppendLine("}");
            builder.AppendLine();

            for (int i = 0; i < items.Count; i++)
            {
                var item = items[i];
                builder.AppendLine($"public sealed class {item.Key} : {item.Type}");
                builder.AppendLine("{");
                builder.AppendLine(1, $"public override string Name => Localizations.Localization.{item.Key};");
                builder.AppendLine("}");
                builder.AppendLine();
            }

            context.AddSource($"SR{Type}s.g.cs", builder.ToString());
        }
    }
}
